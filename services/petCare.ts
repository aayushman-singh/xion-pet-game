import { XIONVerificationService } from './verification';
import { ZkTLSManager } from './zkTLSManager';
import type { PetStatus, CareAction } from '../types/pet';
import type { PetCareActivity } from '../types/achievements';
import { DEFAULT_TIMER_CONFIG, calculateDegradation, type PetCareTimerConfig } from '../types/petCareTimers';

export class PetCareService {
  private verificationService: XIONVerificationService;
  private zkTLSManager: ZkTLSManager;
  private config: PetCareTimerConfig;

  constructor(config?: PetCareTimerConfig) {
    this.verificationService = new XIONVerificationService();
    this.zkTLSManager = ZkTLSManager.getInstance();
    this.config = config || DEFAULT_TIMER_CONFIG;
  }

  async calculateCurrentStatus(status: PetStatus): Promise<PetStatus> {
    const now = Date.now();
    const degradationInfo = calculateDegradation(status.lastUpdated, this.config);
    
    if (!degradationInfo.shouldDegrade) {
      return status;
    }

    // Calculate degradation using the new system
    const degradation = degradationInfo.degradationAmount;
    
    const newStatus: PetStatus = {
      ...status,
      happiness: Math.max(0, status.happiness - degradation),
      energy: Math.max(0, status.energy - degradation),
      lastUpdated: now,
      timestamp: now,
      // Preserve existing proof and signature
      proof: status.proof,
      signature: status.signature
    };

    // Generate new proof for the updated status
    const proof = await this.verificationService.verifyPetCare({
      petId: status.petId,
      activityType: 'degradation',
      duration: degradationInfo.intervalsPassed * this.config.degradationInterval,
      happinessImpact: -degradation,
      timestamp: now,
      signature: '',  // Will be generated by verification service
      proof: null     // Will be generated by verification service
    });

    // Submit status update to contract
    try {
      const zkProof = await this.zkTLSManager.verifyPetStatus(newStatus);
      const txHash = await this.zkTLSManager.submitPetStatusToContract(
        status.petId,
        newStatus,
        zkProof
      );
      
      if (txHash) {
        console.log(`Pet status submitted to contract: ${txHash}`);
      }
    } catch (error) {
      console.error('Failed to submit pet status to contract:', error);
    }

    return {
      ...newStatus,
      proof: proof
    };
  }

  private isActionAllowed(status: PetStatus, action: CareAction): boolean {
    const now = Date.now();
    switch (action.type) {
      case 'feed':
        return now - status.lastFed >= this.config.feedCooldown;
      case 'play':
        return now - status.lastPlayed >= this.config.playCooldown;
      default:
        return false;
    }
  }

  async performCareAction(
    status: PetStatus,
    action: CareAction
  ): Promise<{ newStatus: PetStatus; activity: PetCareActivity }> {
    // First calculate current status with degradation
    status = await this.calculateCurrentStatus(status);

    if (!this.isActionAllowed(status, action)) {
      throw new Error(`${action.type} action is still in cooldown`);
    }

    const now = Date.now();
    const boost = this.config.careBoost;

    // Create the care activity
    const activity: PetCareActivity = {
      petId: action.petId,
      activityType: action.type,
      duration: 0, // Instant action
      happinessImpact: boost,
      timestamp: now,
      signature: '',  // Will be generated by verification service
      proof: null    // Will be generated by verification service
    };

    // Generate proof for the activity
    const activityProof = await this.verificationService.verifyPetCare(activity);
    activity.proof = activityProof;

    // Update status based on action
    const newStatus: PetStatus = {
      ...status,
      happiness: Math.min(100, status.happiness + boost),
      energy: Math.min(100, status.energy + boost),
      lastUpdated: now,
      timestamp: now,
      [action.type === 'feed' ? 'lastFed' : 'lastPlayed']: now
    };

    // Generate proof for the new status
    const statusProof = await this.verificationService.verifyPetCare({
      ...activity,
      activityType: `${action.type}_result`,
    });

    return {
      newStatus: {
        ...newStatus,
        proof: statusProof
      },
      activity: {
        ...activity,
        proof: activityProof
      }
    };
  }

  async getTimeUntilNextAction(status: PetStatus, actionType: 'feed' | 'play'): Promise<number> {
    const now = Date.now();
    const lastActionTime = actionType === 'feed' ? status.lastFed : status.lastPlayed;
    const cooldown = actionType === 'feed' ? this.config.feedCooldown : this.config.playCooldown;
    const timeRemaining = Math.max(0, cooldown - (now - lastActionTime));
    return timeRemaining;
  }

  getStatusDescription(status: PetStatus): string {
    if (status.happiness >= 80) return 'Very Happy';
    if (status.happiness >= 60) return 'Happy';
    if (status.happiness >= 40) return 'Neutral';
    if (status.happiness >= 20) return 'Unhappy';
    return 'Very Unhappy';
  }
}
