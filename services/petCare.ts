import { XIONVerificationService } from './verification';
import type { PetStatus, PetCareConfig, CareAction } from '../types/pet';
import type { PetCareActivity } from '../types/achievements';

export class PetCareService {
  private verificationService: XIONVerificationService;
  private config: PetCareConfig = {
    degradationRate: 10,        // 10% per hour
    degradationInterval: 3600000, // 1 hour
    careBoost: 10,              // 10% increase per action
    careCooldown: 3600000       // 1 hour cooldown
  };

  constructor() {
    this.verificationService = new XIONVerificationService();
  }

  async calculateCurrentStatus(status: PetStatus): Promise<PetStatus> {
    const now = Date.now();
    const hoursSinceUpdate = (now - status.lastUpdated) / this.config.degradationInterval;
    
    if (hoursSinceUpdate < 1) {
      return status;
    }

    // Calculate degradation
    const degradation = Math.floor(hoursSinceUpdate * this.config.degradationRate);
    
    const newStatus: PetStatus = {
      ...status,
      happiness: Math.max(0, status.happiness - degradation),
      energy: Math.max(0, status.energy - degradation),
      lastUpdated: now,
      timestamp: now,
      // Preserve existing proof and signature
      proof: status.proof,
      signature: status.signature
    };

    // Generate new proof for the updated status
    const proof = await this.verificationService.verifyPetCare({
      petId: status.petId,
      activityType: 'degradation',
      duration: hoursSinceUpdate * this.config.degradationInterval,
      happinessImpact: -degradation,
      timestamp: now,
      signature: '',  // Will be generated by verification service
      proof: null     // Will be generated by verification service
    });

    return {
      ...newStatus,
      proof: proof
    };
  }

  private isActionAllowed(status: PetStatus, action: CareAction): boolean {
    const now = Date.now();
    switch (action.type) {
      case 'feed':
        return now - status.lastFed >= this.config.careCooldown;
      case 'play':
        return now - status.lastPlayed >= this.config.careCooldown;
      default:
        return false;
    }
  }

  async performCareAction(
    status: PetStatus,
    action: CareAction
  ): Promise<{ newStatus: PetStatus; activity: PetCareActivity }> {
    // First calculate current status with degradation
    status = await this.calculateCurrentStatus(status);

    if (!this.isActionAllowed(status, action)) {
      throw new Error(`${action.type} action is still in cooldown`);
    }

    const now = Date.now();
    const boost = this.config.careBoost;

    // Create the care activity
    const activity: PetCareActivity = {
      petId: action.petId,
      activityType: action.type,
      duration: 0, // Instant action
      happinessImpact: boost,
      timestamp: now,
      signature: '',  // Will be generated by verification service
      proof: null    // Will be generated by verification service
    };

    // Generate proof for the activity
    const activityProof = await this.verificationService.verifyPetCare(activity);
    activity.proof = activityProof;

    // Update status based on action
    const newStatus: PetStatus = {
      ...status,
      happiness: Math.min(100, status.happiness + boost),
      energy: Math.min(100, status.energy + boost),
      lastUpdated: now,
      timestamp: now,
      [action.type === 'feed' ? 'lastFed' : 'lastPlayed']: now
    };

    // Generate proof for the new status
    const statusProof = await this.verificationService.verifyPetCare({
      ...activity,
      activityType: `${action.type}_result`,
    });

    return {
      newStatus: {
        ...newStatus,
        proof: statusProof
      },
      activity: {
        ...activity,
        proof: activityProof
      }
    };
  }

  async getTimeUntilNextAction(status: PetStatus, actionType: 'feed' | 'play'): Promise<number> {
    const now = Date.now();
    const lastActionTime = actionType === 'feed' ? status.lastFed : status.lastPlayed;
    const timeRemaining = Math.max(0, this.config.careCooldown - (now - lastActionTime));
    return timeRemaining;
  }

  getStatusDescription(status: PetStatus): string {
    if (status.happiness >= 80) return 'Very Happy';
    if (status.happiness >= 60) return 'Happy';
    if (status.happiness >= 40) return 'Neutral';
    if (status.happiness >= 20) return 'Unhappy';
    return 'Very Unhappy';
  }
}
